\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% joe's includes
\usepackage{draftwatermark}
\SetWatermarkText{DRAFT}
\SetWatermarkScale{3}
%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{minted}
\title{Elementary Number Theory - Math 3307 Honors Project: \\ Cryptography}
\author{Joe Cloud}

\begin{document}
\maketitle


\section{Introduction}

Today's computer security relies on encryption algorithms such as RSA and AES. RSA, as covered in chapter 5 of 'Number Theory Through Inquiry' are based on concepts we've developed in class. Using Python 3 I have created a web server that acts as an encryptor/decryptor based on the same concepts from the book. I will cover the details of how I implemented it, the proofs behind, and additional details such as the code itself and challenges I ran into in implementation.

\section{Number Theory}

\subsection{Public Key Cryptography}
This project is built upon the concepts of PKC which exploits a computational limitation- the fact that factoring numbers is an incredibly time and resource intensive task for computers to process. This provides a clever way of masking information - also known as ciphertext. This is accomplished by using a publicly accessible key (hence the title) in order to encrypt the data, this encrypted data cannot be practically decrypted using the same method to encrypt and instead relies on another private key that only the server/'owner' of the key or algorithm knows. RSA is a popular encryption method based on this idea of a public key that allows secure messaging to take place across a network and then decrypted once it is processed by a server.

\subsection{Proofs}

SAMPLE BLOCK FOR DRAFT SAMPLE BLOCK FOR DRAFT - THE NOTATION IS HERE FOR REFERENCE \newline \newline
\LaTeX{} is great at typesetting mathematics. Let $X_1, X_2, \ldots, X_n$ be a sequence of independent and identically distributed random variables with $\text{E}[X_i] = \mu$ and $\text{Var}[X_i] = \sigma^2 < \infty$, and let
\[S_n = \frac{X_1 + X_2 + \cdots + X_n}{n}
      = \frac{1}{n}\sum_{i}^{n} X_i\]
denote their mean. Then as $n$ approaches infinity, the random variables $\sqrt{n}(S_n - \mu)$ converge in distribution to a normal $\mathcal{N}(0, \sigma^2)$.

\subsection{Implemented proof}

Use imp of 5.8 from the book

\section{Programming}
\subsection{Overview}
The application is mainly written in Python and HTML. Flask/Flask-WTF were instrumental in connecting the web page to the program running on the back-end handling input/output of arguments.
Using a home server that I have routed through a localhost tunnel linked to a website- I was able to make the python publicly accessible. This was a factor upon deciding on using Python/Flask as the two combined would make bringing the program to fruition in a much more practical way. 
\subsection{Technical Challenges}
There were a few challenges to implementing an RSA-like algorithm. For one, the ways the keys are generated relied on buffering the entire plaintext value at once processing it as a single string. I originally intended on using Python 2 but switched to Python 3 could scale infinitely with the size of the integer, which solved a lot of other issues although porting what I had written at that point was a hassle. 
Another challenge was related to how the encryption/decryption schemes could be used with practical user input, the current iteration of the project assumes the user will only input an integer value. I originally tested with strings of text and ran into many issues with representing the strings in their ascii integer value form so that they could be processed by the encryptor/decryptor schemes (as those relied on integers as inputs) and then convert it back to a human readable form. There were a lot of issues with this- one example is with leading zeros being omitted by the integer. In detail: I can convert a string of characters to their respective ascii representation, but if their was a leading control character (which may be represented as 0X in decimal) then the leading 0 would be removed as it makes no sense to write 300 as 0300 typically, but for my applications the loss of these values meant the decoding process returned garbage as it returned completely different values. 
\subsection{How to run the program}
The appendix contains a brief overview to running the program, here are more detailed steps:
\subsubsection{Executing the code locally}
On a Linux based machine the sequence of instructions is as follows:
\begin{minted}{bash}
$ pip3 install --upgrade pip #insures pip is updated
$ # This will install the necessary 3rd party packages
$ pip3 install flask
$ pip3 install flask-wtf
$ # Download the code from the github repository, be sure to be in the save directory
$ git clone https://github.com/binarysaurus/Number-Theory-PKC-Project.git
$ cd Number-Theory-PKC-Project
$ python3 test.py
$ # You should now be set to navigate to 127.0.0.1:12345 on your web browser! 
\end{minted}
\subsubsection{Accessing the web server}
In order to use the current working site, please visit http://crypto.joe.cloud/

\subsection{Quick script that tries to hack the key}
Maybe nuke this section
proof otherwise of how long it work take to reverse the factors of the number

\section{Concluding Remarks}
The discussion from the following subsections will have a lot of related ideas as they build upon each other greatly. 
\subsection{What was learned}
There is no aspect of this project that I can think of that did not require me to learn something new in order to accomplish it, from the proofs, to the concepts, to the programming- the language and the tools, even writing this paper in LaTeX. All of it required me to go out and become comfortable using new tools together for the first time- an individual with experience with any of the tools (including the math) will easily pick out parts that could be significantly improved but talk with regards with to improvement is reserved for later subsections. 

\subsection{How can it be improved}
There are some fundamental issues with my implementation of the project. The Chapter in 'Number Theory Through Inquiry' focused on RSA encryption - which although is very important, is not ideal for my application. RSA is most practical in situations were you need to encrypt a form/data before submission from a client-side application, and then transmit the encrypted data to a server to where it will be decrypted and processed. In my program, I allowed a user to encrypt and decrypt a string of digits. So in a hypothetical situation where an unauthorized recipient wanted to gain access to data encrypted using my program, they would need the cipher, key, and knowledge of where to decrypt it.
\subsection{Future goals}
This project has made me much more curious to the inner workings of computer encryption as well as how to exploit vulnerabilities in it- particularly through weak implementations of familiar concepts from Number Theory. \newline
In continuing to develop the project and refining my skills in all topics necessary- I'd like to improve the program by switching to an AES-based encryption/decryption method. This would make the platform more viable as a way of securing files- given the user had a way of protecting their keys.
I would also be interested in making the encryption more general, I have limited input to strings of integers as processing binary/text data, or other data types in general would be more difficult to predict the output from a development standpoint (I have to have a good way of converting the base/codes to digits and vice versa) and more likely to fail if not carefully implemented. 
\newline
Finally, if properly designed, then the algorithm should be modular enough to where it can be improved upon beyond strictly switching to AES- this includes combinations of encryption methods and working on new algorithms.

\section{Appendix}
\subsection{System Requirements}
In order to access the online web application, a user will need a browser with internet access.
To run the program on a personal machine, preferably a *nix based system with Python installed, as well as Flask, and Flask-WTF.
\subsection{Accessing the server} 
To access the web page, please navigate to crypto.joe.cloud
In the case that the server is not accessible, please contact Joe Cloud.
To test the program, input a number and click the first submit button, this will generate the key and cipher text that can be used later to decrypt. In current revisions you must clear the input box for encryption before decrypting.

\newpage
\subsection{Code}
\subsubsection{Main Python program}
\begin{minted}{python}
#This is the main app.py file, this runs the webserver
import os
import math
import itertools
from fractions import gcd
from random import randint
import binascii
import struct

from flask import Flask, render_template, flash, request, url_for
from flask.ext.wtf import Form
from wtforms import Form, TextField, TextAreaField, validators, StringField, SubmitField
from wtforms.validators import Required



DEBUG = True
app = Flask(__name__)
app.config.from_object(__name__)
app.config['SECRET_KEY'] = '7d441f27d441f27567d441f2b6176a'
 

class ReusableForm(Form):
    str_encrypt = TextField('Number to encrypt:')
    str_decrypt = TextField('Encrypted text    :')
    str_key     = TextField('Key of Encrypted :')


@app.route("/", methods=['GET', 'POST'])
def main():
    form = ReusableForm(request.form)
 
    print(form.errors)
    if request.method == 'POST':
        if (request.form['str_encrypt']):
            str_encrypt=request.form['str_encrypt']
            print(str_encrypt)
     
            if form.validate():

                encrypted_data = encryptor(int(str_encrypt))
                flash('Encrypted Text: '+str(encrypted_data[0]))
                flash('Key:            '+str(encrypted_data[1]))
            else:
                flash('All the form fields are required. ')
        elif(request.form['str_decrypt']):
            str_decrypt=request.form['str_decrypt']
            str_key = request.form['str_key']
            print(str_decrypt)
     
            if form.validate():
                decrypted_data = decryptor(int(str_decrypt), int(str_key))
                flash('Decrypted Text: '+str(decrypted_data))
            else:
                flash('All the form fields are required. ')             
 
    return render_template('index.html', form=form)

def is_prime(num):
    if num > 1:
        for i in range(2,num):
            if (num % i) == 0:
                return False;
                break
        else:
            return True;
    else:
        return False;

#Extended euclidean algorithm from:
# https://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Extended_Euclidean_algorithm

def xgcd(b, n):
    x0, x1, y0, y1 = 1, 0, 0, 1
    while n != 0:
        q, b, n = b // n, n, b % n
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return  b, x0, y0

def encryptor(m):
    p = 2**31-1
    q = 2**61-1
    n = p * q
    phi = (p-1)*(q-1)
    
    e = randint(0,phi)
    while gcd(e, phi) != 1:
        e = randint(0,phi)
    
    bezout = xgcd(e, phi)
    
    d = bezout[1]%phi
    
    print("ORIGINAL BEFR: ", m)


    c = pow(m,e,n)
    print("CIPHERTEXT ENC : ", c)
    return c, e

def decryptor(c, e):
    p = 2**31-1
    q = 2**61-1
    n = p * q
    phi = (p-1)*(q-1)
    
    extend_ea = xgcd(e, phi)
    
    d = extend_ea[1]%phi
    

    decode = pow(c,d,n)
    print("ORIGINAL TEXT IN: ", decode)
    return decode


if __name__ == "__main__":
    app.run(host='0.0.0.0', port=12345, debug=True)
\end{minted}
\subsubsection{HTML code for browsers}
\begin{minted}{html}
<!-this is the rendered form that constructs the main page when navigating to the site.->
<!DOCTYPE html>
<html lang="en">

<body>
	<h1>MATH 3307 - HONORS PROJECT - JOE CLOUD</h1>
	<h2>Fall 2016 - Section 001 (85596) - Epperson </h2>
	<p> This program will encrypt a string of digits up to 2^91.</p>
	

        <form action="" method="post">
            {{ form.csrf }}
 
            <div class="input text">
                {{ form.str_encrypt.label }} {{ form.str_encrypt }}
            </div>
 
            <div class="input submit">
                <input type="submit" value="Submit" />
            </div>

             <div class="input text">
                {{ form.str_decrypt.label }} {{ form.str_decrypt }}
            </div>
            <div class="input text">
                {{ form.str_key.label }} {{ form.str_key }}
            </div>
 
            <div class="input submit">
                <input type="submit" value="Submit" />
            </div>
        </form>

        	{% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <ul>
                    {% for message in messages %}
                        <li>{{ message[1] }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        {% endwith %}

</body>
</html>
\end{minted}

Bibliography, quick links, will be formatted properly for final submission:

\end{document}